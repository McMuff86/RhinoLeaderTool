"""
GHPython template: Generate simple door geometry from exported CSV and save 3DM per row.

Usage in Grasshopper (GHPython component):
- Create a GHPython component and add these inputs (right-click → Add input):
  csv_path (Text), out_folder (Text), use_plan_dims (Boolean), name_fields (Text List),
  default_panel_thickness (Number), default_frame_depth (Number), extrusion_depth (Number)
- Optional outputs: preview (Geometry), report (Text)

Suggested defaults:
- use_plan_dims: True
- name_fields: ["text"]
- default_panel_thickness: 40.0 (mm)
- default_frame_depth: 60.0 (mm)
- extrusion_depth: 10.0 (mm)

Expected CSV columns (as generated by write_leaders_to_file_bupc.py):
- "text", "dimstyle", and many user keys. Prefer:
  Mauerlichtbreite_plan / Mauerlichtbreite_Massaufnahme
  Mauerlichthöhe_plan / Mauerlichthöhe_Massaufnahme / Mauerlichthöhe_Massaufnahme_ab_MtR
  Rahmenstärke, Türblattdicke, LeaderGUID

File naming:
- Joins values of name_fields with '_' (missing values skipped). Fallback: LeaderGUID → text → row index.

Notes:
- Geometry is a simple parametric placeholder: a panel and a frame as extrusions in +Z.
- Units: Values treated in model units (e.g., mm). Adapt as needed.
"""

import System
import os
import Rhino
import Rhino.Geometry as rg


# Helper: robust float parse (dot or comma), returns None if not parseable or NA
def to_float(val):
    if val is None:
        return None
    s = str(val).strip()
    if s == "" or s.upper() == "NA":
        return None
    s2 = s.replace(",", ".")
    try:
        return float(s2)
    except Exception:
        return None


def read_csv_table(path):
    import csv
    with open(path, "r", encoding="utf-8") as f:
        rdr = csv.reader(f)
        header = next(rdr, [])
        rows = [row for row in rdr]
    return header, rows


def row_to_dict(header, row):
    data = {}
    for i, h in enumerate(header):
        key = str(h).strip()
        if not key:
            continue
        val = row[i] if i < len(row) else ""
        data[key] = val
    return data


def select_value(data, keys):
    for k in keys:
        if k in data and str(data[k]).strip() != "":
            return data[k]
    return None


def build_door_geometry(width, height, panel_thickness, frame_depth, extrusion_depth):
    """Return (panel_brep, frame_brep). width/height in XY, extruded in +Z."""
    # Panel: rectangle at origin, extruded
    rect_panel = rg.Rectangle3d(rg.Plane.WorldXY, width, height)
    crv_panel = rect_panel.ToNurbsCurve()
    vec = rg.Vector3d(0, 0, extrusion_depth if extrusion_depth else 10.0)
    panel = rg.Extrusion.Create(crv_panel, vec.Z, True)

    # Frame: simple ring: offset rectangle outward by frame_depth/2 and inward by frame_depth/2
    # Here: represent as boundary rectangle minus inner rectangle
    outer_w = width + frame_depth
    outer_h = height + frame_depth
    rect_outer = rg.Rectangle3d(rg.Plane.WorldXY, outer_w, outer_h)
    rect_inner = rg.Rectangle3d(rg.Plane.WorldXY, width, height)
    crv_outer = rect_outer.ToNurbsCurve()
    crv_inner = rect_inner.ToNurbsCurve()
    # Create frame as (outer extrusion) minus (inner extrusion)
    tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance
    outer_solid = rg.Brep.CreateFromExtrusion(crv_outer, vec, True)
    inner_solid = rg.Brep.CreateFromExtrusion(crv_inner, vec, True)
    frame = None
    if outer_solid and inner_solid:
        diff = rg.Brep.CreateBooleanDifference(outer_solid, inner_solid, tol)
        if diff and len(diff) > 0:
            frame = diff[0]
    return panel, frame


def safe_filename(parts):
    sanitized = []
    for p in parts:
        if not p:
            continue
        s = str(p)
        for ch in '\\/:*?"<>|':
            s = s.replace(ch, "-")
        sanitized.append(s)
    name = "_".join(sanitized)
    return name if name else None


def make_name(data, name_fields, row_index):
    # Preferred: provided name_fields
    fields = name_fields or []
    parts = []
    for f in fields:
        v = data.get(f)
        if v is not None and str(v).strip() != "":
            parts.append(str(v).strip())
    nm = safe_filename(parts)
    if nm:
        return nm
    # Fallbacks
    if data.get("LeaderGUID"):
        return safe_filename([data.get("LeaderGUID")]) or ("item_%03d" % (row_index + 1))
    if data.get("text"):
        return safe_filename([data.get("text")]) or ("item_%03d" % (row_index + 1))
    return "item_%03d" % (row_index + 1)


# GHPython inputs expected (with same names):
# csv_path: str
# out_folder: str
# use_plan_dims: bool
# name_fields: list[str]
# default_panel_thickness: float
# default_frame_depth: float
# extrusion_depth: float

def run(csv_path, out_folder, use_plan_dims, name_fields, default_panel_thickness, default_frame_depth, extrusion_depth):
    rep = []
    previews = []
    if not csv_path or not os.path.isfile(csv_path):
        rep.append("CSV not found: %s" % csv_path)
        return previews, "\n".join(rep)
    try:
        header, rows = read_csv_table(csv_path)
    except Exception as e:
        rep.append("CSV read failed: %s" % e)
        return previews, "\n".join(rep)

    # tolerances / defaults
    panel_t = default_panel_thickness if default_panel_thickness is not None else 40.0
    frame_d = default_frame_depth if default_frame_depth is not None else 60.0
    extr_d = extrusion_depth if extrusion_depth is not None else 10.0

    # keys
    w_keys = ["Mauerlichtbreite_plan", "Mauerlichtbreite_Massaufnahme"] if use_plan_dims else ["Mauerlichtbreite_Massaufnahme", "Mauerlichtbreite_plan"]
    h_keys = ["Mauerlichthöhe_plan", "Mauerlichthöhe_Massaufnahme", "Mauerlichthöhe_Massaufnahme_ab_MtR"] if use_plan_dims else ["Mauerlichthöhe_Massaufnahme", "Mauerlichthöhe_Massaufnahme_ab_MtR", "Mauerlichthöhe_plan"]

    for i, row in enumerate(rows):
        data = row_to_dict(header, row)
        # Select dims
        w_raw = select_value(data, w_keys)
        h_raw = select_value(data, h_keys)
        width = to_float(w_raw)
        height = to_float(h_raw)
        if width is None or height is None:
            rep.append("Row %d skipped (missing width/height)" % (i+1))
            continue
        # Optional thickness/depth
        panel_th = to_float(select_value(data, ["Türblattdicke"])) or panel_t
        frame_dep = to_float(select_value(data, ["Rahmenstärke"])) or frame_d

        panel, frame = build_door_geometry(width, height, panel_th, frame_dep, extr_d)
        if panel: previews.append(panel)
        if frame: previews.append(frame)

        # Write file if out_folder provided
        if out_folder and os.path.isdir(out_folder):
            fname = make_name(data, name_fields, i)
            path = os.path.join(out_folder, fname + ".3dm")
            try:
                model = Rhino.FileIO.File3dm()
                if panel:
                    model.Objects.Add(panel)
                if frame:
                    model.Objects.Add(frame)
                # write selected attributes as UserStrings on model for reference
                attrs = Rhino.DocObjects.ObjectAttributes()
                # could also add named user text on model properties (global)
                model.Write(path, 6)
                rep.append("Saved: %s" % path)
            except Exception as e:
                rep.append("Write failed (%s): %s" % (fname, e))
        else:
            if i == 0:
                rep.append("No out_folder or not a directory – writing skipped (preview only)")

    return previews, "\n".join(rep)


# For GH: assign outputs if running inside component where variables exist
try:
    # csv_path, out_folder, use_plan_dims, name_fields, default_panel_thickness, default_frame_depth, extrusion_depth
    preview, report = run(csv_path, out_folder, use_plan_dims, name_fields, default_panel_thickness, default_frame_depth, extrusion_depth)
except NameError:
    # Not in GH – allow simple dry run
    pass


